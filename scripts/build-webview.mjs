import { spawn, spawnSync } from "node:child_process";
import { build, context } from "esbuild";
import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, "..");
const configPath = path.join(repoRoot, "config", "buildDetailsWebview.json");
const assetsPath = path.join(
  repoRoot,
  "src",
  "panels",
  "buildDetails",
  "BuildDetailsWebviewAssets.ts"
);
const cssBundlePath = "out/webview/buildDetails.css";

function resolveBundlePath() {
  const contents = readFileSync(configPath, "utf8");
  const config = JSON.parse(contents);
  if (!config || typeof config.bundlePath !== "string" || config.bundlePath.length === 0) {
    throw new Error("Invalid buildDetailsWebview.json: bundlePath is missing.");
  }
  return config.bundlePath;
}

function syncAssetsFile(bundlePath) {
  const next = `// Generated by scripts/build-webview.mjs. Do not edit directly.\nexport const BUILD_DETAILS_WEBVIEW_BUNDLE_PATH = "${bundlePath}";\nexport const BUILD_DETAILS_WEBVIEW_CSS_PATH = "${cssBundlePath}";\n`;
  let current = "";
  try {
    current = readFileSync(assetsPath, "utf8");
  } catch {
    current = "";
  }
  if (current !== next) {
    writeFileSync(assetsPath, next, "utf8");
  }
}

const bundlePath = resolveBundlePath();
syncAssetsFile(bundlePath);

const outfile = path.join(repoRoot, bundlePath);
mkdirSync(path.dirname(outfile), { recursive: true });
const cssOutfile = path.join(repoRoot, cssBundlePath);
mkdirSync(path.dirname(cssOutfile), { recursive: true });

const entry = path.join(
  repoRoot,
  "src",
  "panels",
  "buildDetails",
  "webview",
  "index.tsx"
);
const cssEntry = path.join(
  repoRoot,
  "src",
  "panels",
  "buildDetails",
  "webview",
  "styles.css"
);
const tailwindConfig = path.join(repoRoot, "tailwind.config.cjs");
const tailwindBin = path.join(
  repoRoot,
  "node_modules",
  ".bin",
  process.platform === "win32" ? "tailwindcss.cmd" : "tailwindcss"
);

const watch = process.argv.includes("--watch");

function buildTailwind({ watch: shouldWatch }) {
  const args = ["-i", cssEntry, "-o", cssOutfile, "--config", tailwindConfig];
  if (shouldWatch) {
    args.push("--watch");
    const processHandle = spawn(tailwindBin, args, { stdio: "inherit" });
    processHandle.on("exit", (code) => {
      if (typeof code === "number" && code !== 0) {
        process.exit(code);
      }
    });
    return processHandle;
  }
  const result = spawnSync(tailwindBin, args, { stdio: "inherit" });
  if (result.status !== 0) {
    process.exit(result.status ?? 1);
  }
  return null;
}

const buildOptions = {
  entryPoints: [entry],
  bundle: true,
  format: "iife",
  platform: "browser",
  target: ["es2020"],
  tsconfig: path.join(repoRoot, "tsconfig.webview.json"),
  outfile,
  define: {
    "process.env.NODE_ENV": JSON.stringify(watch ? "development" : "production")
  },
  minify: !watch,
  sourcemap: watch,
  logLevel: "info"
};

if (watch) {
  const tailwindProcess = buildTailwind({ watch: true });
  const ctx = await context(buildOptions);
  await ctx.watch();
  process.on("SIGINT", async () => {
    await ctx.dispose();
    if (tailwindProcess) {
      tailwindProcess.kill("SIGINT");
    }
    process.exit(0);
  });
} else {
  buildTailwind({ watch: false });
  await build(buildOptions);
}
