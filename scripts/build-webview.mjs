import { spawn, spawnSync } from "node:child_process";
import { build, context } from "esbuild";
import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, "..");
const tailwindConfig = path.join(repoRoot, "tailwind.config.cjs");
const tailwindBin = path.join(
  repoRoot,
  "node_modules",
  ".bin",
  process.platform === "win32" ? "tailwindcss.cmd" : "tailwindcss"
);

const webviews = [
  {
    name: "buildDetails",
    configPath: path.join(repoRoot, "config", "buildDetailsWebview.json"),
    assetsPath: path.join(repoRoot, "src", "panels", "buildDetails", "BuildDetailsWebviewAssets.ts"),
    bundleConst: "BUILD_DETAILS_WEBVIEW_BUNDLE_PATH",
    cssConst: "BUILD_DETAILS_WEBVIEW_CSS_PATH",
    cssBundlePath: "out/webview/buildDetails.css",
    entry: path.join(repoRoot, "src", "panels", "buildDetails", "webview", "index.tsx"),
    cssEntry: path.join(repoRoot, "src", "panels", "buildDetails", "webview", "styles.css")
  },
  {
    name: "nodeDetails",
    configPath: path.join(repoRoot, "config", "nodeDetailsWebview.json"),
    assetsPath: path.join(repoRoot, "src", "panels", "nodeDetails", "NodeDetailsWebviewAssets.ts"),
    bundleConst: "NODE_DETAILS_WEBVIEW_BUNDLE_PATH",
    cssConst: "NODE_DETAILS_WEBVIEW_CSS_PATH",
    cssBundlePath: "out/webview/nodeDetails.css",
    entry: path.join(repoRoot, "src", "panels", "nodeDetails", "webview", "index.tsx"),
    cssEntry: path.join(repoRoot, "src", "panels", "nodeDetails", "webview", "styles.css")
  }
];

function resolveBundlePath(configPath, name) {
  const contents = readFileSync(configPath, "utf8");
  const config = JSON.parse(contents);
  if (!config || typeof config.bundlePath !== "string" || config.bundlePath.length === 0) {
    throw new Error(`Invalid ${name} webview config: bundlePath is missing.`);
  }
  return config.bundlePath;
}

function syncAssetsFile(assetsPath, bundleConst, cssConst, bundlePath, cssBundlePath) {
  const next = `// Generated by scripts/build-webview.mjs. Do not edit directly.\nexport const ${bundleConst} = "${bundlePath}";\nexport const ${cssConst} = "${cssBundlePath}";\n`;
  let current = "";
  try {
    current = readFileSync(assetsPath, "utf8");
  } catch {
    current = "";
  }
  if (current !== next) {
    writeFileSync(assetsPath, next, "utf8");
  }
}

function prepareWebview(webview) {
  const bundlePath = resolveBundlePath(webview.configPath, webview.name);
  syncAssetsFile(
    webview.assetsPath,
    webview.bundleConst,
    webview.cssConst,
    bundlePath,
    webview.cssBundlePath
  );

  const outfile = path.join(repoRoot, bundlePath);
  mkdirSync(path.dirname(outfile), { recursive: true });
  const cssOutfile = path.join(repoRoot, webview.cssBundlePath);
  mkdirSync(path.dirname(cssOutfile), { recursive: true });

  return { ...webview, bundlePath, outfile, cssOutfile };
}

const watch = process.argv.includes("--watch");
const preparedWebviews = webviews.map(prepareWebview);

function buildTailwind(webview, shouldWatch) {
  const args = ["-i", webview.cssEntry, "-o", webview.cssOutfile, "--config", tailwindConfig];
  if (shouldWatch) {
    args.push("--watch");
    const processHandle = spawn(tailwindBin, args, { stdio: "inherit" });
    processHandle.on("exit", (code) => {
      if (typeof code === "number" && code !== 0) {
        process.exit(code);
      }
    });
    return processHandle;
  }
  const result = spawnSync(tailwindBin, args, { stdio: "inherit" });
  if (result.status !== 0) {
    process.exit(result.status ?? 1);
  }
  return null;
}

function buildOptions(webview) {
  return {
    entryPoints: [webview.entry],
    bundle: true,
    format: "iife",
    platform: "browser",
    target: ["es2020"],
    tsconfig: path.join(repoRoot, "tsconfig.webview.json"),
    outfile: webview.outfile,
    define: {
      "process.env.NODE_ENV": JSON.stringify(watch ? "development" : "production")
    },
    minify: !watch,
    sourcemap: watch,
    logLevel: "info"
  };
}

if (watch) {
  const tailwindProcesses = preparedWebviews.map((webview) => buildTailwind(webview, true));
  const contexts = await Promise.all(
    preparedWebviews.map((webview) => context(buildOptions(webview)))
  );
  await Promise.all(contexts.map((ctx) => ctx.watch()));
  process.on("SIGINT", async () => {
    await Promise.all(contexts.map((ctx) => ctx.dispose()));
    for (const processHandle of tailwindProcesses) {
      processHandle?.kill("SIGINT");
    }
    process.exit(0);
  });
} else {
  preparedWebviews.forEach((webview) => buildTailwind(webview, false));
  await Promise.all(preparedWebviews.map((webview) => build(buildOptions(webview))));
}
